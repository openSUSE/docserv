#!/usr/bin/env python3
#
# Copyright (c) 2018 SUSE Linux GmbH
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of version 3 of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, contact SUSE LLC.
#
# To contact SUSE about this file by physical or electronic mail,
# you may find current contact information at www.suse.com

"""
Generates a basic default XML configuration for docserv from
Git repositories.
"""

import os
import re
import sys
import pygit2
from lxml import etree
from xml.dom import minidom
from contextlib import contextmanager

FIXME = "FIXME"

def get_origin_url(path):
    """Return the repo origin url

    :param path: The path to local repository
    :type path: str

    :return: the URL address
    :rtype: str
    """
    repo = pygit2.Repository(path)
    origin = repo.remotes["origin"]
    url = origin.url
    # example: ('git@')('github.com')(':')('openSUSE/docserv.git')
    regex = r'(^[a-zA-Z]+@)([a-zA-Z.]+)([:])(.*)'
    match = re.match(regex, url)
    if match:
        # substitute ':' with '/'
        url = url.replace(match.group(3), "/")
        # substitute 'git@' with 'https://'
        url = url.replace(match.group(1), "https://")
    return url

def get_version(name):
    """Returns version from product name
    Example:
    >>> get_version("SLE12SP4")
    '12 SP4'

    :param name: string with a product name
    :type name: str

    :return: the version of a product
    :rtype: str
    """
    # example: ('SLE')('12')('SP4')
    version_regex = r'(^[a-zA-Z_]+)([0-9.]+)?([a-zA-Z0-9.]+)?'
    match = re.match(version_regex, name)
    if match.group(2):
            # substitute 'SLE' with '', removing product name
            version = re.sub(r'(^[a-zA-Z_]+)', "", name)
            if match.group(3):
                # replace '12' with '12 ', adding space
                version = version.replace(match.group(2), match.group(2) + " ")
            # returning '12 SP4'
            return version
    return name

def prettify(tree, indent="  "):
    """Return a pretty-printed XML string for the element.

    :param tree: The XML tree
    :type tree: :class:`xml.etree.ElementTree.ElementTree`

    :param indent: string used for indentation (usually spaces)
    :type indent: str

    :return: the indented string
    :rtype: str | byte
    """
    rough_string = etree.tostring(tree.getroot(), encoding='UTF-8')
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent=indent)

def generate_config(args, git_url, branches, subdeliverables, version="0.9.10", contact=None):
    """Generate the configuration file.

    :param args: The namespace containing the scripts arguments
    :param str git_url: The repo origin url

    :param branches: The branch name and DC files on it, for example:
               {'develop': ['DC-FOO-all', 'DC-FOO-install-quick'], ... }
    :type branches: dict

    :param dict subdeliverables: a dictionary with lists as keys like:
               {'DC-file1-all': ['book.one', 'art.two'], 'DC-file2-all': [], ...}

    :param str version: the schema version to use
    :param str contact: the contact email address
    """
    root = etree.Element("product", productid=FIXME, schemaversion=version)
    etree.SubElement(root, "name").text = FIXME
    etree.SubElement(root, "shortname").text = FIXME
    maintainers = etree.SubElement(root, "maintainers")
    etree.SubElement(maintainers, "contact").text = FIXME if not contact else contact

    for language in args.langs:
        description = etree.SubElement(root, "desc", default="0", lang=language)
        etree.SubElement(description, "p").text = FIXME

    for branch in branches:
        if branch.startswith("trans/"):
            continue
        setid = branch.replace("maintenance/", "")
        product_version = get_version(setid)
        docset = etree.SubElement(root, "docset", setid=setid, lifecycle=FIXME)

        etree.SubElement(docset, "version").text = product_version
        builddocs = etree.SubElement(docset, "builddocs")
        # Optionally <git>, look at product/git
        etree.SubElement(builddocs, "git", remote=git_url)

        for language in args.langs:
            if language == "en-us":
                lang = etree.SubElement(builddocs, "language",
                                        default="1", lang="en-us")
                etree.SubElement(lang, "branch").text = branch
                has_all_dc = "1"
                for dc_file in branches[branch]:
                    if "-all" in dc_file:
                        has_all_dc = "0"
                for dc_file in branches[branch]:
                    deliverable = etree.SubElement(lang, "deliverable")
                    etree.SubElement(deliverable, "dc", ).text = dc_file
                    dc_all_file = dc_file.endswith("-all")
                    attrs = {'pdf': "0" if dc_all_file else "1",
                             'epub': "0" if dc_all_file else "1",
                             'html': "1" if dc_all_file else has_all_dc,
                             'single-html': "0" if dc_all_file else "1",
                             }
                    etree.SubElement(deliverable, "format", **attrs)
                    if dc_file.endswith("-all"):
                        for sub in subdeliverables[branch + dc_file]:
                            etree.SubElement(deliverable, "subdeliverable", ).text = sub
            else:
                lang = etree.SubElement(builddocs, "language", lang=language)
                if branch.startswith("maintenance/") or branch.startswith("maint/"):
                    tmp = branch.replace("maintenance/", "").replace("maint/", "")
                    if "trans/%s" % tmp in branches:
                        branch = "trans/%s" % tmp
                etree.SubElement(lang, "branch").text = branch
                etree.SubElement(lang, "subdir").text = FIXME
                untrans = etree.SubElement(lang, "untranslated")
                deliverable = etree.SubElement(untrans, "deliverable")
                etree.SubElement(deliverable, "dc").text = FIXME
        # TODO: add extralinks as comments
        # extralinks = etree.SubElement(docset, "extralinks")
        # etree.SubElement(extralinks, "link", href=FIXME).text = "SOME DESCRIPTION"

    tree = etree.ElementTree(root)
    configfile = os.getcwd() + "/config.xml"
    print("Find the config file at {!r}".format(configfile))
    # tree.write(configfile)
    with open(configfile, 'w+t') as fh:
        fh.write(prettify(tree))
    print("Done.")

@contextmanager
def switchbranch(repo):
    """Context manager to checkout branches

    :param repo: the repo to the Git repository
    :type repo: :class:`pygit2.Repository`
    :return: function, see: checkout_branch
    :rtype: function reference
    """
    def checkout_branch(branches):
        """Generator to iterate over branches, which checks out the current
            branch automatically

        :param list branches: the list of branches as strings
        :yield: current branch as string
        """
        for branch in branches:
            remote_branch = repo.branches.remote["origin/" + branch]
            ref_branch = repo.lookup_branch(remote_branch.branch_name, pygit2.GIT_BRANCH_REMOTE)
            repo.checkout(ref_branch)
            yield branch
    # save initial branch
    initial_branch = repo.head.shorthand
    initial_ref = repo.lookup_branch(initial_branch, pygit2.GIT_BRANCH_ALL)
    try:
        yield checkout_branch
    finally:
        # change back to initial branch
        repo.checkout(initial_ref)

def get_dc_files(path, branches, filter_dc=None):
    """Collect all DC files in all branches.

    :param str path: the path to the Git repository
    :param dict branches: A dictionary with lists as keys like
         {'branch1': [], 'branch2': [], ...}
    :param filter_dc: filter
    :return: a dictionary with all DC files found in each branch
    :rtype: dict
    """
    repo = pygit2.Repository(path)
    tmp = branches
    with switchbranch(repo) as checkout_branch:
        for branch in checkout_branch(branches):
            path2git = path + "/en" if "en" in os.listdir(path) else path
            tmp[branch] = collect_dc_files(path2git, filter_dc)
    return tmp

def get_subdeliverables(path, dc_files):
    """Collect all subdeliverables from DC-*-all files in all branches.

    :param str path: the path to the Git repository
    :param dict dc_files: A dictionary with lists as keys like
         {'branch1': [], 'branch2': [], ...}
    :return: a dictionary with all subdeliverables found in each branch with
         lists as keys like {'branch1DC-file1-all': [], 'branch2DC-file2-all': [], ...}
    :rtype: dict
    """
    result = {}
    repo = pygit2.Repository(path)
    with switchbranch(repo) as checkout_branch:
        for branch in checkout_branch(branches):
            path2git = path + "/en" if "en" in os.listdir(path) else path
            for dc_file in dc_files[branch]:
                if dc_file.endswith("-all"):
                    result[branch + dc_file] = collect_subdeliverables(path2git, dc_file)
    return result

def collect_subdeliverables(path, dc_file):
    """Collect all subdeliverables from given DC-file

    :param str path: the path to the Git repository
    :param str dc_file: the DC-file to look into
    :return: a list with all subdeliverables found after looking in this DC-file
    :rtype: list
    """
    result = []
    main = ""
    # example: ('MAIN', '=', '"', 'MAIN.susestorage.xml', '"')
    #        ('ROOTID', '=', None, 'book.storage.admin', None)
    regex = r'([A-Z]+)(=)("|\')?([\w\.\-]+)("|\')?'
    with open(os.path.join(path, dc_file), "r") as f:
        for line in f:
            match = re.match(regex, line)
            if match:
                if match.group(1) == "MAIN":
                    main = match.group(4)
    if main:
        try:
            root = etree.parse(os.path.join(path + "/xml", main))
            namespaces = dict(d="http://docbook.org/ns/docbook", xi="http://www.w3.org/2001/XInclude")
            xpaths = "/set/xi:include|/set/book/xi:include|" \
                     "/d:set/xi:include|/d:set/d:book/xi:include"
            xi_includes = root.xpath(xpaths, namespaces=namespaces)
            for xi in xi_includes:
                filename = xi.attrib.get("href")
                fileroot = etree.parse(os.path.join(path + "/xml", filename))
                xmlid = fileroot.xpath("/d:*/@xml:id|/*/@id", namespaces=namespaces)
                if xmlid:
                    result.append(xmlid[0])
        except etree.XMLSyntaxError as e:
            print("!!! Exception:", e)
    return result

def collect_dc_files(path, filter_dc):
    """Collect all DC files in current branch

    :param str path: the path to the Git repository
    :param str filter_dc: filter
    :return: a list with all DC files found in this branch
    :rtype: list
    """
    result = []
    for f in os.listdir(path):
        if os.path.isfile(os.path.join(path, f)):
            if filter_dc is not None:
                if f.startswith("DC-") and filter_dc in f:
                    result.append(f)
            else:
                if f.startswith("DC-"):
                    result.append(f)
    return sorted(result)

def get_git_branches(path):
    """Return all the branches of a Git repository. Replace "origin/" with ""

    :param str path: the path to the Git repository
    :return: dictionary of all branches with their DC files, for example:
            {'develop': ['DC-foo', 'DC-foo-all'],
             'master':  ['DC-foo', 'DC-foo-all'],
             # ... more items pruned ...
             }
    :rtype: dict
    """
    repo = pygit2.Repository(path)
    result = {}
    for branch in sorted(repo.listall_branches(pygit2.GIT_BRANCH_REMOTE)):
        branch_wo_origin = branch.replace("origin/", "")
        if branch.startswith('maintenance/') or branch.startswith('trans/'):
            result[branch] = []
        elif branch_wo_origin == "develop" \
             or branch_wo_origin == "master" \
             or branch.startswith('origin/trans/') \
             or branch.startswith('origin/maint/') \
             or branch.startswith('origin/maintenance/'):
            result[branch_wo_origin] = []
    return result

def check_langs(langs, message, attempts = 3):
    """Checks if langs were given, gives three input attempts

    :param str langs: Language(s) to check
    :param str message: Message to print
    :param int attempts: User attempts to type in languges that validate
    :return: list of checked and formatted language(s)
    :rtype: list
    """
    attempts = 3
    languages = ("en-us de-de fr-fr pt-br ja-jp zh-cn es-es "
                      "it-it ko-kr hu-hu zh-tw cs-cz ar-ar pl-pl "
                      "ru-ru").split(" ")
    while attempts:
        if not langs:
            langs = input(message)
        # format given langs, remove white space
        langs = langs.replace("_", "-").strip().lower().split(",")
        langs = [lang.strip() for lang in langs if not lang == '']
        # create a diff from our list and the languages list from above
        diff = set(langs).difference(languages)
        if diff or not langs:
            attempts -= 1
            # reset langs because they're not good
            langs = ""
            print("Unknown language {} found.".format(diff))
        else:
            return langs
    sys.exit("Expected one or more of these:\n"
        "{}".format(", ".join(languages)))

def check_args(args):
    """Checks if no argumets were set when running the script and asks for them.

    :param args: The namespace containing the scripts arguments
    :type args: :class:`argparse.Namespace`
    """
    # checking path
    while not args.path or not os.path.exists(args.path):
        args.path = input("# Path to the git repository: ")
    # checking languages
    lang_message = "# Languages (separated by comma): "
    args.langs = check_langs(args.langs, lang_message)
    # checking default language
    default_message = "# Default language: "
    args.default_lang = check_langs(args.default_lang, default_message)[0]
    # insert default_lang at first position:
    if args.default_lang in args.langs:
        args.langs.remove(args.default_lang)
    args.langs.insert(0, args.default_lang)
    # checking filter
    if not args.filter:
        args.filter = input("# Filter (can be left empty): ")
    # checking contact
    while not args.contact:
        args.contact = input("# Contact (minimum one email): ")

def parse_cli(cliargs=None):
    """Parse CLI with :class:`argparse.ArgumentParser` and return parsed result.

    :param list cliargs: Arguments to parse or None (=use sys.argv)
    :return: parsed CLI result
    :rtype: :class:`argparse.Namespace`
    """
    import argparse

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("-l", "--languages",
                        dest="langs",
                        help=("Uses one or more languages in the format "
                              "'language_country'. "
                              "Upper and lower case is irrelevant."
                              ),
                        )
    parser.add_argument("-d", "--default",
                        dest="default_lang",
                        help="Default language",
                        )
    parser.add_argument("-f", "--filter",
                        help="Expects DC files which to focus on",
                        )
    parser.add_argument("-m", "--contact",
                        help="The contact email address",
                        )
    parser.add_argument("path",
                        nargs='?',
                        metavar="PATH",
                        help="Path to the repository",
                        )

    args = parser.parse_args(args=cliargs)

    # do some checks:
    check_args(args)
    return args

if __name__ == "__main__":
    args = parse_cli()
    print(args)

    branches = get_git_branches(args.path)
    dc_files = get_dc_files(args.path, branches, filter_dc=args.filter)
    subdeliverables = get_subdeliverables(args.path, dc_files)
    git_url = get_origin_url(args.path)
    generate_config(args, git_url ,branches, subdeliverables, contact=args.contact)
    sys.exit(0)
