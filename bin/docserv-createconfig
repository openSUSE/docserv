#!/usr/bin/env python3
#
# Copyright (c) 2018 SUSE Linux GmbH
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of version 3 of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, contact SUSE LLC.
#
# To contact SUSE about this file by physical or electronic mail,
# you may find current contact information at www.suse.com

"""
Generates a basic default XML configuration for docserv from
Git repositories.
"""

import os
import re
import sys
import pygit2
from lxml import etree

FIXME = "FIXME"

def get_origin_url(path):
    """Return the repo origin url

    :param path: The path to local repository
    :type path: str

    :return: the URL address
    :rtype: str
    """
    repo = pygit2.Repository(path)
    origin = repo.remotes["origin"]
    url = origin.url
    # example: ('git@')('github.com')(':')('openSUSE/docserv.git')
    regex = r'(^[a-zA-Z]+@)([a-zA-Z.]+)([:])(.*)'
    match = re.match(regex, url)
    if match:
        # substitute ':' with '/'
        url = url.replace(match.group(3), "/")
        # substitute 'git@' with 'https://'
        url = url.replace(match.group(1), "https://")
    return url

def get_version(name):
    """Returns version from product name
    Example:
    >>> get_version("SLE12SP4")
    '12 SP4'

    :param name: string with a product name
    :type name: str

    :return: the version of a product
    :rtype: str
    """
    # example: ('SLE')('12')('SP4')
    version_regex = r'(^[a-zA-Z_]+)([0-9.]+)?([a-zA-Z0-9.]+)?'
    match = re.match(version_regex, name)
    if match.group(2):
            # substitute 'SLE' with '', removing product name
            version = re.sub(r'(^[a-zA-Z_]+)', "", name)
            if match.group(3):
                # replace '12' with '12 ', adding space
                version = version.replace(match.group(2), match.group(2) + " ")
            # returning '12 SP4'
            return version
    return name

def prettify(root):
    """Return a pretty-printed XML string for the element.

    :param root: The XML tree
    :type root: :class:`xml.etree._Element`

    :return: the indented string
    :rtype: str
    """
    return etree.tostring(root, pretty_print=True, encoding="unicode")

def generate_config(languages, default_lang, git_url, branches, version="0.9.10", contact=None):
    """Generate the configuration file.

    :param languages: The allowed languages
    :type languages: list

    :param branches: The branch name and DC files on it, for example:
               {'develop': ['DC-FOO-all', 'DC-FOO-install-quick'], ... }
    :type branches: dict

    :param str schemaversion: the schema version to use
    :param str contact: the contact email address
    """
    root = etree.Element("product", productid=FIXME, schemaversion=version)
    etree.SubElement(root, "name").text = FIXME
    etree.SubElement(root, "shortname").text = FIXME
    maintainers = etree.SubElement(root, "maintainers")
    etree.SubElement(maintainers, "contact").text = FIXME if not contact else contact

    for language in languages:
        description = etree.SubElement(root, "desc", default="0", lang=language)
        etree.SubElement(description, "p").text = FIXME

    for branch in branches:
        if branch.startswith("trans/"):
            continue
        setid = branch.replace("maintenance/", "")
        product_version = get_version(setid)
        docset = etree.SubElement(root, "docset", setid=setid, lifecycle=FIXME)

        etree.SubElement(docset, "version").text = product_version
        builddocs = etree.SubElement(docset, "builddocs")
        # Optionally <git>, look at product/git
        etree.SubElement(builddocs, "git", remote=git_url)

        for language in languages:
            if language == "en-us":
                lang = etree.SubElement(builddocs, "language",
                                        default="1", lang="en-us")
                etree.SubElement(lang, "branch").text = branch
                has_all_dc = "1"
                for dc_file in branches[branch]:
                    if "-all" in dc_file:
                        has_all_dc = "0"
                for dc_file in branches[branch]:
                    deliverable = etree.SubElement(lang, "deliverable")
                    etree.SubElement(deliverable, "dc", ).text = dc_file
                    dc_all_file = dc_file.endswith("-all")
                    attrs = {'pdf': "0" if dc_all_file else "1",
                             'epub': "0" if dc_all_file else "1",
                             'html': "1" if dc_all_file else has_all_dc,
                             'single-html': "0" if dc_all_file else "1",
                             }
                    etree.SubElement(deliverable, "format", **attrs)
            else:
                lang = etree.SubElement(builddocs, "language", lang=language)
                if branch.startswith("maintenance/") or branch.startswith("maint/"):
                    tmp = branch.replace("maintenance/", "").replace("maint/", "")
                    if "trans/%s" % tmp in branches:
                        branch = "trans/%s" % tmp
                etree.SubElement(lang, "branch").text = branch
                etree.SubElement(lang, "subdir").text = FIXME
                untrans = etree.SubElement(lang, "untranslated")
                deliverable = etree.SubElement(untrans, "deliverable")
                etree.SubElement(deliverable, "dc").text = FIXME
        # TODO: add extralinks as comments
        # extralinks = etree.SubElement(docset, "extralinks")
        # etree.SubElement(extralinks, "link", href=FIXME).text = "SOME DESCRIPTION"

    configfile = os.getcwd() + "/config.xml"
    print("Find the config file at {!r}".format(configfile))

    with open(configfile, 'w+t') as fh:
        fh.write(prettify(root))
    print("Done.")


def get_dc_files(path, branches, filter_dc=None):
    """Collect all DC files in branches.

    :param str path: the path to the Git repository
    :param dict branches: A dictionary with lists as keys like
         {'branch1': [], 'branch2': [], ...}
    :param filter_dc: filter
    :return: a dictionary with all DC files found in this branch
    :rtype: dict
    """
    repo = pygit2.Repository(path)
    tmp = branches
    # save current branch
    curr_branch = repo.head.shorthand
    curr_ref = repo.lookup_branch(curr_branch, pygit2.GIT_BRANCH_ALL)

    for name in branches:
        branch = repo.branches.remote["origin/" + name]
        ref = repo.lookup_branch(branch.branch_name, pygit2.GIT_BRANCH_REMOTE)
        repo.checkout(ref)
        result = []
        for f in os.listdir(path):
            if os.path.isfile(os.path.join(path, f)):
                if filter_dc is not None:
                    if f.startswith("DC-") and filter_dc in f:
                        result.append(f)
                else:
                    if f.startswith("DC-"):
                        result.append(f)
        tmp[name] = sorted(result)
    # change back to initial branch
    repo.checkout(curr_ref)
    return tmp


def get_git_branches(path):
    """Return all the branches of a Git repository. Replace "origin/" with ""

    :param str path: the path to the Git repository
    :return: dictionary of all branches with their DC files, for example:
            {'develop': ['DC-foo', 'DC-foo-all'],
             'master':  ['DC-foo', 'DC-foo-all'],
             # ... more items pruned ...
             }
    :rtype: dict
    """
    repo = pygit2.Repository(path)
    result = {}
    for branch in sorted(repo.listall_branches(pygit2.GIT_BRANCH_REMOTE)):
        branch_wo_origin = branch.replace("origin/", "")
        if branch.startswith('maintenance/') or branch.startswith('trans/'):
            result[branch] = []
        elif branch_wo_origin == "develop" \
             or branch_wo_origin == "master" \
             or branch.startswith('origin/trans/') \
             or branch.startswith('origin/maint/') \
             or branch.startswith('origin/maintenance/'):
            result[branch_wo_origin] = []
    return result

def check_langs(langs, message, attempts = 3):
    """Checks if langs were given, gives three input attempts

    :param str langs: Language(s) to check
    :param str message: Message to print
    :param int attempts: User attempts to type in languges that validate
    :return: list of checked and formatted language(s)
    :rtype: list
    """
    attempts = 3
    languages = ("en-us de-de fr-fr pt-br ja-jp zh-cn es-es "
                      "it-it ko-kr hu-hu zh-tw cs-cz ar-ar pl-pl "
                      "ru-ru").split(" ")
    while attempts:
        if not langs:
            langs = input(message)
        # format given langs, remove white space
        langs = langs.replace("_", "-").strip().lower().split(",")
        langs = [lang.strip() for lang in langs if not lang == '']
        # create a diff from our list and the languages list from above
        diff = set(langs).difference(languages)
        if diff or not langs:
            attempts -= 1
            # reset langs because they're not good
            langs = ""
            print("Unknown language {} found.".format(diff))
        else:
            return langs
    sys.exit("Expected one or more of these:\n"
        "{}".format(", ".join(languages)))

def check_args(args):
    """Checks if no argumets were set when running the script and asks for them.

    :param args: The namespace containing the scripts arguments
    :type args: :class:`argparse.Namespace`
    """
    # checking path
    while not args.path or not os.path.exists(args.path):
        args.path = input("# Path to the git repository: ")
    # checking languages
    lang_message = "# Languages (separated by comma): "
    args.langs = check_langs(args.langs, lang_message)
    # checking default language
    default_message = "# Default language: "
    args.default_lang = check_langs(args.default_lang, default_message)[0]
    # insert default_lang at first position:
    if args.default_lang in args.langs:
        args.langs.remove(args.default_lang)
    args.langs.insert(0, args.default_lang)
    # checking filter
    if not args.filter:
        args.filter = input("# Filter (can be left empty): ")
    # checking contact
    while not args.contact:
        args.contact = input("# Contact (minimum one email): ")

def parse_cli(cliargs=None):
    """Parse CLI with :class:`argparse.ArgumentParser` and return parsed result.

    :param list cliargs: Arguments to parse or None (=use sys.argv)
    :return: parsed CLI result
    :rtype: :class:`argparse.Namespace`
    """
    import argparse

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("-l", "--languages",
                        dest="langs",
                        help=("Uses one or more languages in the format "
                              "'language_country'. "
                              "Upper and lower case is irrelevant."
                              ),
                        )
    parser.add_argument("-d", "--default",
                        dest="default_lang",
                        help="Default language",
                        )
    parser.add_argument("-f", "--filter",
                        help="Expects DC files which to focus on",
                        )
    parser.add_argument("-m", "--contact",
                        help="The contact email address",
                        )
    parser.add_argument("path",
                        nargs='?',
                        metavar="PATH",
                        help="Path to the repository",
                        )

    args = parser.parse_args(args=cliargs)

    # do some checks:
    check_args(args)
    return args

if __name__ == "__main__":
    args = parse_cli()
    print(args)

    branches = get_git_branches(args.path)
    dc_files = get_dc_files(args.path, branches, filter_dc=args.filter)
    git_url = get_origin_url(args.path)
    generate_config(args.langs, args.default_lang, git_url ,branches, contact=args.contact)
    sys.exit(0)
