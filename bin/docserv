#!/usr/bin/env python3

import json
import time
import subprocess
import shlex
import datetime
import os
import sys
import threading
import queue
import socket
import configparser
import logging
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
from SocketServer import ThreadingMixIn
my_env = os.environ

class Documentation:
    def __init__(self, path):
        read_conf_dir(path)

    def read_conf_dir(self, path):
        pass

class Docserv:
    def __init__(self, argv):
        parse_config(argv)
        self.build_queue = queue.Queue()
        self.cur_builds_queue = queue.Queue()
    
    def parse_config(self, argv):
        config = configparser.ConfigParser()
        if len(argv) == 1:
            argv[1] = "docserv"
        logging.info("Reading /etc/docserv/%s.ini" % argv[1])
        config.read("/etc/docserv/%s.ini" % argv[1])
        self.config['build']['repo_dir'] =      config['build']['repo_dir']
        self.config['build']['templdate_dir'] = config['build']['template_dir']
        self.config['build']['config_dir'] =    config['build']['config_dir']
        self.config['server']['host'] =     config['server']['host']
        self.config['server']['port'] =         config['server']['port']

    def start(self):
        # start everything
        thread_receive = threading.Thread(target=self.listen_request)
        thread_receive.start()
        for i in os.cpu_count():
            thread_builds[i] = threading.Thread(target=self.build)
            thread_builds[i].start()
        # to have a clean shutdown, wait for all threads to finish
        thread_receive.join()
        for i in os.cpu_count():
            thread_builds[i].join()

    def build(self):
        while( True ):
            section = self.queued_docs.get(block=True, timeout=None)
            building_docs.put(section)
            timestamp = False
            if build(section) == 0:
                timestamp = time.strftime( '%Y-%m-%d %H:%M:%S' )
            finished_docs.put((section, timestamp))
            cmd = '/suse/lxbuch/doc/daps-autobuild/daps-autobuild --config /suse/lxbuch/doc/daps-autobuild/daps-autobuild_docserv.xml --schema /suse/lxbuch/doc/daps-autobuild/daps-autobuild.rnc --notify --sections %s' % section
            cmd = shlex.split(cmd)
            s = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            s.communicate()[0]
            rc = s.returncode
            cmd = '/suse/lxbuch/doc/portwinestain/portwinestain'
            cmd = shlex.split(cmd)
            s = subprocess.Popen(cmd)
            s.wait()

    def listen(self):
        self.rest = QueuingRESTServer((self.config['server']['host'], self.config['server']['port']), RESTServer, self.build_queue, self.cur_builds_queue)
        try:
            myServer.serve_forever()
        except KeyboardInterrupt:
            pass
        self.rest.server_close()

class QueuingRESTServer(ThreadedRESTServer):
    def __init__(self, server_address, RequestHandlerClass, build_queue, cur_builds_queue, bind_and_activate=True):
        ThreadedRESTServer((self.config['server']['host'], self.config['server']['port']), RESTServer)
        self.build_queue = build_queue
        self.cur_builds_queue = cur_builds_queue

class ThreadedRESTServer(ThreadingMixIn, RESTServer):
    """Handle requests in a separate thread."""

class RESTServer(BaseHTTPRequestHandler):
    def _set_headers(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
	def do_GET(self):
        _set_headers()
		self.wfile.write(bytes("<p>You accessed path: %s</p>" % self.path, "utf-8"))
	def do_POST(self):
		content_length = int(self.headers['Content-Length'])
		post_data = self.rfile.read(content_length)
		_set_headers()
		client.close()

if __name__ == "__main__":
    docserv = new Docserv(sys.argv)
    docserv.start()
